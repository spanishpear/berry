use crate::ident::Descriptor;
use crate::package::Package;
use nom::{
  IResult, Parser,
  bytes::complete::{is_not, tag, take_while, take_while1},
  character::complete::{char, newline, space1},
  combinator::opt,
  multi::fold_many0,
  sequence::{pair, preceded, separated_pair, terminated},
};

/// A serialized representation of a yarn lockfile.
#[derive(Debug)]
pub struct Lockfile {
  /// Lockfile version and cache key
  pub metadata: Metadata,
  /// The entries in the lockfile
  pub entries: Vec<Entry>,
  /// Optional resolutions section (key -> value)
  pub resolutions: Option<Vec<(String, String)>>,
  /// Optional constraints section (key -> value)
  pub constraints: Option<Vec<(String, String)>>,
}

/// A single lockfile entry is a mapping of one or more descriptors to a single package
#[derive(Debug)]
pub struct Entry {
  /// The descriptors of the entry
  pub descriptors: Vec<Descriptor>,
  /// The package of the entry
  pub package: Package,
}

impl Entry {
  pub fn new(descriptors: Vec<Descriptor>, package: Package) -> Self {
    Self {
      descriptors,
      package,
    }
  }
}

/// The start of the metadata block
/// Typically at the start of the file
///
/// # Examples
///
/// ```
/// __metadata:
///   version: 8
///   cacheKey: 9
/// ```
///
/// will often be represented as:
///
/// ```
/// Metadata {
///   version: "8",
///   cache_key: "9",
/// }
#[derive(Debug)]
pub struct Metadata {
  /// The version of the lockfile
  pub version: String,
  /// The cache key of the lockfile
  pub cache_key: String,
}

impl Metadata {
  /// Create a new Metadata from a version and a cache key
  pub fn new(version: String, cache_key: String) -> Self {
    Self { version, cache_key }
  }
}

/// A line of metadata is a key-value pair, with a space-based indent
/// e.g. `  version: 8`
pub(crate) fn parse_metadata_line(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    preceded(
      space1,
      separated_pair(
        take_while(|c: char| c.is_alphabetic() || c == '_'),
        pair(char(':'), space1),
        is_not("\r\n"),
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Parses the __metadata block of a yarn lockfile
///
/// # Examples
///
/// ```
/// __metadata:
///   version: 8
///   cacheKey: 9
/// ```
pub(crate) fn parse_metadata(input: &str) -> IResult<&str, Metadata> {
  let (rest, _) = terminated(tag("__metadata:"), newline).parse(input)?;
  let (rest, version_line) = parse_metadata_line(rest)?;
  let (rest, cache_key_line) = parse_metadata_line(rest)?;

  // todo(shrey): consider a more robust way to do this
  // where we dont rely on the ordering
  let version = version_line.1.trim_matches('"');
  let cache_key = cache_key_line.1.trim_matches('"');

  Ok((
    rest,
    Metadata::new(version.to_string(), cache_key.to_string()),
  ))
}

// NOTE: A faster approach **could** be to just consume three lines, and not even use nom
/// Parse a yarn lockfile header
/// It matches explicitly the yarn lockfile header comments
/// and the newline that follows
///
pub(crate) fn parse_yarn_header(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    pair(
      terminated(
        tag("# This file is generated by running \"yarn install\" inside your project."),
        newline,
      ),
      terminated(
        tag("# Manual changes might be lost - proceed with caution!"),
        newline,
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Parse a single top-level key-value line indented with two spaces: `  key: value`.
fn parse_top_kv_line(input: &str) -> IResult<&str, (&str, &str)> {
  let (rest, (_, key, _, _, val, _)) = (
    tag("  "),
    take_while1(|c: char| c != ':' && c != '\n' && c != '\r'),
    char(':'),
    space1,
    is_not("\r\n"),
    opt(newline),
  )
    .parse(input)?;

  Ok((rest, (key, val)))
}

/// Parse a top-level block like:
/// resolutions:\n
///   foo@^1: npm:1.2.3\n
fn parse_top_level_kv_block<'a>(
  header: &'static str,
) -> impl Fn(&'a str) -> IResult<&'a str, Vec<(&'a str, &'a str)>> {
  move |input: &str| {
    let (rest, (_, _, entries)) = (
      tag(header),
      newline,
      fold_many0(parse_top_kv_line, Vec::new, |mut acc, item| {
        acc.push(item);
        acc
      }),
    )
      .parse(input)?;

    Ok((rest, entries))
  }
}

pub(crate) fn parse_resolutions(input: &str) -> IResult<&str, Vec<(String, String)>> {
  let (rest, entries) = parse_top_level_kv_block("resolutions:")(input)?;
  let owned = entries
    .into_iter()
    .map(|(k, v)| {
      (
        k.trim_matches('"').trim().to_string(),
        v.trim_matches('"').to_string(),
      )
    })
    .collect();
  Ok((rest, owned))
}

pub(crate) fn parse_constraints(input: &str) -> IResult<&str, Vec<(String, String)>> {
  let (rest, entries) = parse_top_level_kv_block("constraints:")(input)?;
  let owned = entries
    .into_iter()
    .map(|(k, v)| (k.trim().to_string(), v.trim_matches('"').to_string()))
    .collect();
  Ok((rest, owned))
}

#[cfg(test)]
mod tests_parse_r_c {
  use super::*;

  #[test]
  fn test_parse_top_level_resolutions_block() {
    let input = r#"resolutions:
  lodash@^4.0.0: npm:4.17.21
  "@scope/pkg@^1": "npm:^1.2.3"
"#;
    let (rest, resolutions) = parse_resolutions(input).expect("parse resolutions");
    assert!(rest.is_empty());
    assert_eq!(resolutions.len(), 2);
    assert_eq!(resolutions[0].0, "lodash@^4.0.0");
    assert_eq!(resolutions[0].1, "npm:4.17.21");
    assert_eq!(resolutions[1].0, "@scope/pkg@^1");
    assert_eq!(resolutions[1].1, "npm:^1.2.3");
  }

  #[test]
  fn test_parse_top_level_constraints_block() {
    let input = r"constraints:
  react@^18: npm:^18.2.0
";
    let (rest, constraints) = parse_constraints(input).expect("parse constraints");
    assert!(rest.is_empty());
    assert_eq!(constraints.len(), 1);
    assert_eq!(constraints[0].0, "react@^18");
    assert_eq!(constraints[0].1, "npm:^18.2.0");
  }
}

#[cfg(test)]
mod tests_header_meta {
  use super::*;
  use nom::{
    AsChar, Parser, bytes::complete::take_while, character::complete::newline, sequence::terminated,
  };

  /// Helper combinator to take an entire line, including the newline character
  fn take_whole_line(input: &str) -> IResult<&str, &str> {
    terminated(take_while(|c| !AsChar::is_newline(c)), newline).parse(input)
  }

  #[test]
  fn test_parse_lockfile_header() {
    let file_contents = include_str!("../../../fixtures/berry.lock");
    let result = parse_yarn_header(file_contents);
    assert!(result.is_ok());
    let (leftover, (l1, l2)) = result.unwrap();

    // we have eaten the extra newline at the end of the header
    assert_ne!(leftover, "\n");

    // confirm we have the right lines
    assert_eq!(
      l1,
      "# This file is generated by running \"yarn install\" inside your project."
    );
    assert_eq!(l2, "# Manual changes might be lost - proceed with caution!");

    // make sure leftover doesn't include the header
    assert!(
      !leftover
        .contains("# This file is generated by running \"yarn install\" inside your project.")
    );
    assert!(!leftover.contains("# Manual changes might be lost - proceed with caution!"));

    // confirm the cursor is now at metadata
    // such that we are sure we have eaten the newline
    let (_, next) = take_whole_line(leftover).unwrap();
    assert_eq!(next, "__metadata:");
  }

  #[test]
  fn test_parse_take_until_eol() {
    let input = "hello world\n";
    let result = take_whole_line(input);
    let (leftover, consumed) = result.unwrap();
    assert_eq!(leftover, "");
    assert_eq!(consumed, "hello world");
  }

  #[test]
  fn test_parse_metadata() {
    let metadata_block = r#"__metadata:
  version: "8"
  cacheKey: "9"

"#;
    let result = parse_metadata(metadata_block);
    assert!(result.is_ok());

    let (rest, metadata) = result.unwrap();
    assert_eq!(rest, "\n");
    assert_eq!(metadata.version, "8");
    assert_eq!(metadata.cache_key, "9");
  }
}
