use crate::package::LockfileEntry;
use nom::{
  IResult, Parser,
  bytes::complete::{is_not, tag, take_while},
  character::complete::{char, newline, space1},
  sequence::{pair, preceded, separated_pair, terminated},
};

/// A serialized representation of a yarn lockfile.
#[derive(Debug)]
pub struct Lockfile {
  /// Lockfile version and cache key
  pub metadata: Metadata,
  /// The entries in the lockfile
  pub entries: Vec<LockfileEntry>,
}

/// The start of the metadata block
/// Typically at the start of the file
#[derive(Debug)]
pub struct Metadata {
  pub version: String,
  pub cache_key: String,
}

impl Metadata {
  pub const fn new(version: String, cache_key: String) -> Self {
    Self { version, cache_key }
  }
}

/// A line of metadata is a key-value pair, with a space-based indent
/// e.g. `  version: 8`
pub(crate) fn parse_metadata_line(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    preceded(
      space1,
      separated_pair(
        take_while(|c: char| c.is_alphabetic() || c == '_'),
        pair(char(':'), space1),
        is_not("\r\n"),
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Parses the __metadata block of a yarn lockfile
/// e.g.
/// __metadata:
///   version: 8
///   cacheKey: 9
pub(crate) fn parse_metadata(input: &str) -> IResult<&str, Metadata> {
  let (rest, _) = terminated(tag("__metadata:"), newline).parse(input)?;
  let (rest, version_line) = parse_metadata_line(rest)?;
  let (rest, cache_key_line) = parse_metadata_line(rest)?;

  // todo(shrey): consider a more robust way to do this
  // where we dont rely on the ordering
  let version = version_line.1.trim_matches('"');
  let cache_key = cache_key_line.1.trim_matches('"');

  Ok((
    rest,
    Metadata::new(version.to_string(), cache_key.to_string()),
  ))
}

/// Parse a yarn lockfile header
/// It matches explicitly the yarn lockfile header comments
/// and the newline that follows
///
/// NOTE: A faster approach **could** be to just consume three lines, and not even use nom
pub(crate) fn parse_yarn_header(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    pair(
      terminated(
        tag("# This file is generated by running \"yarn install\" inside your project."),
        newline,
      ),
      terminated(
        tag("# Manual changes might be lost - proceed with caution!"),
        newline,
      ),
    ),
    newline,
  )
  .parse(input)
}

#[cfg(test)]
mod tests {
  use super::*;
  use nom::{
    AsChar, Parser, bytes::complete::take_while, character::complete::newline, sequence::terminated,
  };

  /// Helper combinator to take an entire line, including the newline character
  fn take_whole_line(input: &str) -> IResult<&str, &str> {
    terminated(take_while(|c| !AsChar::is_newline(c)), newline).parse(input)
  }

  #[test]
  fn test_parse_lockfile_header() {
    let file_contents = include_str!("../../../fixtures/berry.lock");
    let result = parse_yarn_header(file_contents);
    assert!(result.is_ok());
    let (leftover, (l1, l2)) = result.unwrap();

    // we have eaten the extra newline at the end of the header
    assert_ne!(leftover, "\n");

    // confirm we have the right lines
    assert_eq!(
      l1,
      "# This file is generated by running \"yarn install\" inside your project."
    );
    assert_eq!(l2, "# Manual changes might be lost - proceed with caution!");

    // make sure leftover doesn't include the header
    assert!(
      !leftover
        .contains("# This file is generated by running \"yarn install\" inside your project.")
    );
    assert!(!leftover.contains("# Manual changes might be lost - proceed with caution!"));

    // confirm the cursor is now at metadata
    // such that we are sure we have eaten the newline
    let (_, next) = take_whole_line(leftover).unwrap();
    assert_eq!(next, "__metadata:");
  }

  #[test]
  fn test_parse_take_until_eol() {
    let input = "hello world\n";
    let result = take_whole_line(input);
    let (leftover, consumed) = result.unwrap();
    assert_eq!(leftover, "");
    assert_eq!(consumed, "hello world");
  }

  #[test]
  fn test_parse_metadata() {
    let metadata_block = r#"__metadata:
  version: "8"
  cacheKey: "9"

"#;
    let result = parse_metadata(metadata_block);
    assert!(result.is_ok());

    let (rest, metadata) = result.unwrap();
    assert_eq!(rest, "\n");
    assert_eq!(metadata.version, "8");
    assert_eq!(metadata.cache_key, "9");
  }
}
