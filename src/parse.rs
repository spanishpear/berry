use nom::{
  AsChar, IResult, Parser,
  bytes::{complete::take_while, tag},
  character::complete::newline,
  multi::fold_many_m_n,
  sequence::{pair, terminated},
};

use crate::lockfile::Lockfile;

/// Parse a yarn lockfile header
/// It matches explicitly the yarn lockfile header comments
/// and the newline that follows
///
/// NOTE: A faster approach **could** be to just consume three lines, and not even use nom
fn parse_yarn_header(input: &str) -> IResult<&str, (&str, &str)> {
  terminated(
    pair(
      terminated(
        tag("# This file is generated by running \"yarn install\" inside your project."),
        newline,
      ),
      terminated(
        tag("# Manual changes might be lost - proceed with caution!"),
        newline,
      ),
    ),
    newline,
  )
  .parse(input)
}

/// Entrypoint for parsing a yarn lockfile
pub fn parse_lockfile(file_contents: &str) -> IResult<&str, Lockfile> {
  let (input, (_, _)) = parse_yarn_header(file_contents)?;

  todo!("actually parse the lockfile");
}

/// Helper combinator to take an entire line, including the newline character
#[cfg(test)]
fn take_whole_line(input: &str) -> IResult<&str, &str> {
  terminated(take_while(|c| !AsChar::is_newline(c)), newline).parse(input)
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_parse_lockfile_header() {
    let file_contents = include_str!("../fixtures/berry.lock");
    let result = parse_yarn_header(file_contents);
    assert!(result.is_ok());
    let (leftover, (l1, l2)) = result.unwrap();

    // we have eaten the extra newline at the end of the header
    assert_ne!(leftover, "\n");

    // confirm we have the right lines
    assert_eq!(
      l1,
      "# This file is generated by running \"yarn install\" inside your project."
    );
    assert_eq!(l2, "# Manual changes might be lost - proceed with caution!");

    // make sure leftover doesn't include the header
    assert!(
      !leftover
        .contains("# This file is generated by running \"yarn install\" inside your project.")
    );
    assert!(!leftover.contains("# Manual changes might be lost - proceed with caution!"));

    // confirm the cursor is now at metadata
    // such that we are sure we have eaten the newline
    let (_, next) = take_whole_line(leftover).unwrap();
    assert_eq!(next, "__metadata:");
  }

  #[test]
  fn test_parse_take_until_eol() {
    let input = "hello world\n";
    let result = take_whole_line(input);
    let (leftover, consumed) = result.unwrap();
    assert_eq!(leftover, "");
    assert_eq!(consumed, "hello world");
  }
}
