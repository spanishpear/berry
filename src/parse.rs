use nom::{
  AsChar, IResult, Parser, bytes::complete::take_while, character::complete::newline,
  sequence::pair,
};

use crate::lockfile::Lockfile;

/// Parse a yarn lockfile header
/// We have two options:
///  - Parse using `tag` for the string contents across two lines
///  - just parse the first two lines, regardless of the contents
///
/// We'll probably pick the second option, as it is faster(?)
/// We can discard the results, we don't need it
fn parse_yarn_header(input: &str) -> IResult<&str, ()> {
  // take 3 lines, contents included, but discard the results
  //FIXME: is there a more idiomatic way to do this 3 times
  //fold?id
  let (leftover, _) = take_whole_line(input)?;
  let (leftover, _) = take_whole_line(leftover)?;
  let (leftover, _) = take_whole_line(leftover)?;

  // return the leftover input
  Ok((leftover, ()))
}

pub fn parse_lockfile(file_contents: &str) -> IResult<&str, Lockfile> {
  let (_leftover, ()) = parse_yarn_header(file_contents)?;
  todo!();
}

/// Helper combinator to take until the end of the line
/// Does not consume the newline character
/// TODO: Do i ever want to support / think about CRLF?
/// TODO: error handling? typing?
fn take_whole_line(input: &str) -> IResult<&str, (&str, char)> {
  pair(take_while(|c| !AsChar::is_newline(c)), newline).parse(input)
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn test_parse_lockfile_header() {
    let file_contents = include_str!("../fixtures/berry.lock");
    let result = parse_yarn_header(file_contents);
    assert!(result.is_ok());
    let (leftover, ()) = result.unwrap();
    // make sure leftover doesn't include the header
    assert!(
      !leftover
        .contains("# This file is generated by running \"yarn install\" inside your project.")
    );
    assert!(!leftover.contains("# Manual changes might be lost - proceed with caution!"));
  }

  #[test]
  fn test_parse_take_until_eol() {
    let input = "hello world\n";
    let result = take_whole_line(input);
    let (leftover, consumed) = result.unwrap();
    let (content, newline) = consumed;
    assert_eq!(leftover, "");
    assert_eq!(content, "hello world");
    assert_eq!(newline, '\n');
  }
}
